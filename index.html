<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vokabelextraktor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Cropper.js für die Zuschneide-Funktion -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.js" defer></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Stellt sicher, dass das Cropper-Bild nicht zu groß wird */
        #camera-preview-image-container > img {
            max-width: 100%;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen">
    <div class="container mx-auto p-4 max-w-2xl w-full">
        <div class="bg-white rounded-2xl shadow-lg p-6 sm:p-8">
            <header class="text-center mb-6">
                <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">Vokabelextraktor</h1>
                <p class="text-gray-600 mt-2">Extrahiere Vokabeln aus Bildern oder PDFs und speichere sie direkt in Google Sheets.</p>
            </header>

            <div id="auth-container" class="text-center">
                <input type="text" id="api-key-input" placeholder="Dein Google API Key" class="w-full p-3 border border-gray-300 rounded-lg mb-2 text-center" value="">
                <input type="text" id="client-id-input" placeholder="Deine Google Client ID" class="w-full p-3 border border-gray-300 rounded-lg mb-4 text-center" value="">
                <button id="authorize_button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg w-full transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Mit Google anmelden</button>
                <button id="signout_button" class="hidden bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-6 rounded-lg w-full mt-2 transition duration-300">Abmelden</button>
            </div>

            <main id="app-container" class="hidden">
                <div class="mb-4">
                    <label for="custom-filename-input" class="block text-sm font-medium text-gray-700 mb-1">Benutzerdefinierter Dateiname (optional):</label>
                    <input type="text" id="custom-filename-input" class="w-full p-3 border border-gray-300 rounded-lg" placeholder="z.B. Lektion 5 - Unregelmäßige Verben">
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <label for="camera-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></svg>
                        <span>Kamera</span>
                    </label>
                    <input type="file" id="camera-input" accept="image/*" capture="environment" class="hidden">
                    
                    <label for="upload-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                        <span>Dateien hochladen</span>
                    </label>
                    <input type="file" id="upload-input" accept="image/*,application/pdf" class="hidden" multiple>
                    
                    <button id="paste-button" class="cursor-pointer bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                        <span>Zwischenablage</span>
                    </button>
                </div>
                
                <div id="action-buttons" class="flex justify-center gap-4 mb-6">
                    <button id="start-processing-button" class="hidden cursor-pointer bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                        <span>Verarbeitung starten</span>
                    </button>
                    <button id="clear-queue-button" class="hidden cursor-pointer bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                        <span>Warteschlange leeren</span>
                    </button>
                </div>

                <div id="preview-container" class="mb-6 text-center hidden">
                     <h2 class="text-xl font-semibold mb-3">Vorschau der Warteschlange</h2>
                    <div id="previews-wrapper" class="flex flex-wrap gap-4 justify-center p-4 bg-gray-50 rounded-lg"></div>
                </div>

                <div id="status-container" class="text-center p-4 bg-gray-50 rounded-lg min-h-[100px] flex flex-col items-center justify-center">
                    <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-12 w-12 hidden mb-2"></div>
                    <p id="status-text" class="text-gray-500">Bitte wähle eine oder mehrere Dateien aus.</p>
                </div>

                <div id="results-container" class="mt-6 text-center hidden">
                    <h2 class="text-xl font-semibold mb-3">Ergebnisse</h2>
                    <div id="result-links" class="space-y-3">
                       <!-- Links werden hier dynamisch eingefügt -->
                    </div>
                </div>
            </main>
        </div>
        <footer class="text-center mt-4 text-sm text-gray-500">
            <p>&copy; 2025 Vokabelextraktor. Erstellt mit Gemini & Google Sheets API.</p>
            <p class="text-xs mt-1 text-gray-400">Version: 26.11.25 22:15</p>
        </footer>
    </div>
    
    <!-- Modal for Camera Preview and Cropping -->
    <div id="camera-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 max-w-3xl w-full">
            <h2 class="text-2xl font-bold mb-4 text-center">Bild anpassen</h2>
            <div id="camera-preview-image-container" class="mb-4 max-h-[60vh] overflow-hidden bg-gray-200">
                <img id="camera-preview-image" src="" alt="Kameravorschau">
            </div>
            <div class="flex flex-col sm:flex-row justify-center items-center gap-4">
                <button id="retake-photo-button" class="w-full sm:w-auto cursor-pointer bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300">Neu aufnehmen</button>
                <button id="add-selection-to-queue-button" class="w-full sm:w-auto cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300">Auswahl zur Warteschlange</button>
                <button id="finish-selection-button" class="w-full sm:w-auto cursor-pointer bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300">Auswahl abgeschlossen</button>
            </div>
        </div>
    </div>


<script type="text/javascript">
    window.onload = function() {
        const savedApiKey = localStorage.getItem('vokabelAppApiKey');
        const savedClientId = localStorage.getItem('vokabelAppClientId');
        if (savedApiKey) {
            apiKeyInput.value = savedApiKey;
        }
        if (savedClientId) {
            clientIdInput.value = savedClientId;
        }
    };

    const authorizeButton = document.getElementById('authorize_button');
    const signoutButton = document.getElementById('signout_button');
    const apiKeyInput = document.getElementById('api-key-input');
    const clientIdInput = document.getElementById('client-id-input');
    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    const cameraInput = document.getElementById('camera-input');
    const uploadInput = document.getElementById('upload-input');
    const pasteButton = document.getElementById('paste-button');
    const startProcessingButton = document.getElementById('start-processing-button');
    const clearQueueButton = document.getElementById('clear-queue-button');
    const customFilenameInput = document.getElementById('custom-filename-input');
    const previewContainer = document.getElementById('preview-container');
    const previewsWrapper = document.getElementById('previews-wrapper');
    const statusContainer = document.getElementById('status-container');
    const statusText = document.getElementById('status-text');
    const loader = document.getElementById('loader');
    const resultsContainer = document.getElementById('results-container');
    const resultLinks = document.getElementById('result-links');
    
    // Modal elements
    const cameraModal = document.getElementById('camera-modal');
    const cameraPreviewImage = document.getElementById('camera-preview-image');
    const retakePhotoButton = document.getElementById('retake-photo-button');
    const addSelectionToQueueButton = document.getElementById('add-selection-to-queue-button');
    const finishSelectionButton = document.getElementById('finish-selection-button');

    let gapiInited = false;
    let gisInited = false;
    let tokenClient;
    let fileQueue = [];
    let cropper;
    
    const SCOPES = 'https://www.googleapis.com/auth/drive';

    authorizeButton.onclick = handleAuthClick;
    signoutButton.onclick = handleSignoutClick;

    gapi.load('client', initializeGapiClient);
    
    const gsiScript = document.createElement('script');
    gsiScript.src = 'https://accounts.google.com/gsi/client';
    gsiScript.async = true;
    gsiScript.defer = true;
    gsiScript.onload = initializeGisClient;
    document.body.appendChild(gsiScript);

    async function initializeGapiClient() {
        await gapi.client.init({
            discoveryDocs: [
                'https://sheets.googleapis.com/$discovery/rest?version=v4',
                'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
            ],
        });
        gapiInited = true;
        maybeEnableButtons();
    }

    function initializeGisClient() {
        gisInited = true;
        maybeEnableButtons();
    }

    function maybeEnableButtons() {
        if (gapiInited && gisInited) {
            authorizeButton.disabled = false;
            trySilentSignIn();
        }
    }

    function trySilentSignIn() {
        const apiKey = apiKeyInput.value.trim();
        const clientId = clientIdInput.value.trim();
        if (apiKey && clientId) {
            gapi.client.setApiKey(apiKey);
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: clientId,
                scope: SCOPES,
                callback: (resp) => {
                    if (resp.error === undefined) {
                        updateUIVisibility(true);
                    } else {
                        console.log('Stille Anmeldung fehlgeschlagen. Manuelle Anmeldung erforderlich.');
                    }
                },
            });
            tokenClient.requestAccessToken({ prompt: 'none' });
        }
    }

    function handleAuthClick() {
        const apiKey = apiKeyInput.value.trim();
        const clientId = clientIdInput.value.trim();
        if (!apiKey || !clientId) {
            updateStatus('Bitte gib zuerst deinen API Key und deine Client ID ein.', true);
            return;
        }

        localStorage.setItem('vokabelAppApiKey', apiKey);
        localStorage.setItem('vokabelAppClientId', clientId);

        gapi.client.setApiKey(apiKey);
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: clientId,
            scope: SCOPES,
            callback: (resp) => { 
                if (resp.error !== undefined) {
                    console.error('Authentication error:', resp);
                    updateStatus(`Anmeldefehler: ${resp.error_description || resp.error}`, true);
                    return;
                }
                updateUIVisibility(true);
            },
        });
        tokenClient.requestAccessToken({prompt: 'select_account'});
    }

    function handleSignoutClick() {
        localStorage.removeItem('vokabelAppApiKey');
        localStorage.removeItem('vokabelAppClientId');
        apiKeyInput.value = '';
        clientIdInput.value = '';

        const token = gapi.client.getToken();
        if (token !== null) {
            google.accounts.oauth2.revoke(token.access_token);
            gapi.client.setToken('');
            updateUIVisibility(false);
        }
    }

    function updateUIVisibility(isSignedIn) {
        if (isSignedIn) {
            authContainer.classList.add('hidden');
            appContainer.classList.remove('hidden');
            signoutButton.classList.remove('hidden');
            authorizeButton.classList.add('hidden');
            updateStatus('Anmeldung erfolgreich! Du kannst jetzt Dateien hochladen.');
        } else {
            authContainer.classList.remove('hidden');
            appContainer.classList.add('hidden');
            signoutButton.classList.add('hidden');
            authorizeButton.classList.remove('hidden');
            updateStatus('Du wurdest abgemeldet.');
            resultsContainer.classList.add('hidden');
        }
    }

    cameraInput.addEventListener('change', handleCameraInput);
    uploadInput.addEventListener('change', (event) => addFilesToQueue(event.target.files));
    pasteButton.addEventListener('click', handlePaste);
    startProcessingButton.addEventListener('click', processQueue);
    clearQueueButton.addEventListener('click', clearQueue);
    
    // Modal button listeners
    retakePhotoButton.addEventListener('click', () => cameraInput.click());
    addSelectionToQueueButton.addEventListener('click', addSelectionToQueue);
    finishSelectionButton.addEventListener('click', closeCameraModal);


    function handleCameraInput(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            cameraPreviewImage.src = e.target.result;
            cameraModal.classList.remove('hidden');
            
            if (cropper) {
                cropper.destroy();
            }

            cropper = new Cropper(cameraPreviewImage, {
                aspectRatio: NaN, // Free crop
                viewMode: 1,      // Prevent crop box from extending beyond the canvas
                background: false,
            });
        };
        reader.readAsDataURL(file);
    }

    function addSelectionToQueue() {
        if (!cropper) return;
        cropper.getCroppedCanvas({
            imageSmoothingQuality: 'high',
        }).toBlob((blob) => {
            const file = new File([blob], `camera-selection-${Date.now()}.png`, { type: 'image/png' });
            addFilesToQueue([file]);
            // Give user feedback
            const originalButtonText = addSelectionToQueueButton.innerHTML;
            addSelectionToQueueButton.innerHTML = '<span>Hinzugefügt!</span>';
            addSelectionToQueueButton.classList.add('bg-green-500', 'hover:bg-green-600');
            setTimeout(() => {
                addSelectionToQueueButton.innerHTML = originalButtonText;
                addSelectionToQueueButton.classList.remove('bg-green-500', 'hover:bg-green-600');
            }, 1000);
        }, 'image/png');
    }

    function closeCameraModal() {
        cameraModal.classList.add('hidden');
        if (cropper) {
            cropper.destroy();
            cropper = null;
        }
        cameraPreviewImage.src = '';
        cameraInput.value = '';
    }

    async function handlePaste() {
        try {
            if (!navigator.clipboard?.read) {
                 updateStatus('Dein Browser unterstützt das Einfügen aus der Zwischenablage nicht.', true);
                 return;
            }
            const clipboardItems = await navigator.clipboard.read();
            let imageBlob = null;
            for (const item of clipboardItems) {
                const imageType = item.types.find(type => type.startsWith('image/'));
                if (imageType) {
                    imageBlob = await item.getType(imageType);
                    break;
                }
            }
            if (imageBlob) {
                const file = new File([imageBlob], "clipboard-image.png", { type: imageBlob.type });
                addFilesToQueue([file]);
            } else {
                updateStatus('Kein Bild in der Zwischenablage gefunden.', true);
            }
        } catch (error) {
            console.error('Fehler beim Einfügen:', error);
            updateStatus(`Fehler beim Zugriff auf die Zwischenablage: ${error.message}`, true);
        }
    }

    function addFilesToQueue(fileList) {
        if (!fileList || fileList.length === 0) return;
        const files = Array.from(fileList);
        for (const file of files) {
            fileQueue.push({ file: file, timestamp: new Date() });
        }
        updateQueuePreview();
    }

    function removeFromQueue(indexToRemove) {
        fileQueue.splice(indexToRemove, 1);
        updateQueuePreview();
    }

    async function updateQueuePreview() {
        previewsWrapper.innerHTML = '';
        previewContainer.classList.toggle('hidden', fileQueue.length === 0);

        fileQueue.forEach(async (item, index) => {
            if (item.file.type.startsWith('image/')) {
                const previewWrapper = document.createElement('div');
                previewWrapper.className = 'relative flex-shrink-0';
                
                const base64Data = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(item.file);
                });
                
                const img = document.createElement('img');
                img.src = base64Data;
                img.alt = `Vorschau ${item.file.name}`;
                img.className = "max-h-32 rounded-lg shadow-md";
                
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16"><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/></svg>';
                deleteBtn.className = "absolute top-0 right-0 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center font-bold -translate-y-1/2 translate-x-1/2 shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50";
                deleteBtn.setAttribute('aria-label', 'Aus der Warteschlange entfernen');
                deleteBtn.onclick = () => removeFromQueue(index);
                
                previewWrapper.appendChild(img);
                previewWrapper.appendChild(deleteBtn);
                previewsWrapper.appendChild(previewWrapper);
            }
        });

        if (fileQueue.length > 0) {
            updateStatus(`${fileQueue.length} Datei(en) zur Verarbeitung bereit.`);
            startProcessingButton.classList.remove('hidden');
            clearQueueButton.classList.remove('hidden');
        } else {
            updateStatus('Bitte wähle eine oder mehrere Dateien aus.');
            startProcessingButton.classList.add('hidden');
            clearQueueButton.classList.add('hidden');
        }
    }
    
    function clearQueue() {
        fileQueue = [];
        updateQueuePreview();
    }

    async function processQueue() {
        if (fileQueue.length === 0) return;
        
        resultsContainer.classList.add('hidden');
        resultLinks.innerHTML = '';
        
        const sortedQueue = fileQueue.sort((a, b) => a.timestamp - b.timestamp);
        let allVocabulary = [];
        let allSentences = [];
        let detectedLanguage = 'english'; // Default language

        for (let i = 0; i < sortedQueue.length; i++) {
            const item = sortedQueue[i];
            const file = item.file;
            updateStatus(`[${i + 1}/${sortedQueue.length}] Analysiere: ${file.name}`, false, true);
            
            const base64Data = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = err => reject(err);
                reader.readAsDataURL(file);
            });
            
            const data = await processFile(file, base64Data);
            if (data) {
                if (i === 0) { // Set language from the first successfully processed file
                    detectedLanguage = data.language;
                }
                allVocabulary.push(...data.vocabulary);
                allSentences.push(...data.sentences);
            }
        }
        
        updateStatus('Alle Dateien analysiert. Starte Upload zu Google Drive...', false, true);

        await uploadCombinedData({
            language: detectedLanguage,
            vocabulary: allVocabulary,
            sentences: allSentences
        });

        updateStatus(`Alle ${sortedQueue.length} Dateien erfolgreich verarbeitet!`, false, false);
        fileQueue = [];
        updateQueuePreview(); // To hide buttons and clear preview
        customFilenameInput.value = ''; 
    }
    
    async function processFile(file, base64Data) {
        const pureBase64 = base64Data.split(',')[1];
        const systemPrompt = `Du bist ein Assistent zur Vokabelextraktion. Deine Aufgabe ist es, aus einer Datei (Bild oder PDF) Vokabeln und Beispielsätze zu extrahieren.
1.  Identifiziere ZUERST die Ausgangssprache des Textes. Es kann nur 'english' oder 'french' sein.
2.  Extrahiere die Vokabeln und ihre deutsche Übersetzung.
3.  Extrahiere die Beispielsätze UND ÜBERSETZE JEDEN SATZ INS DEUTSCHE.
4.  Gib das Ergebnis IMMER im JSON-Format zurück, das dem angegebenen Schema entspricht. Das 'source'-Feld enthält den Originaltext, das 'german'-Feld die deutsche Übersetzung. Wenn nichts gefunden wird, gib leere Listen und 'english' als Standardsprache zurück.`;
        
        const userQuery = "Extrahiere die Sprache, Vokabeln und Beispielsätze aus der folgenden Datei.";
        
        const payload = {
            systemInstruction: { parts: [{ text: systemPrompt }] },
            contents: [{ parts: [ { text: userQuery }, { inlineData: { mimeType: file.type, data: pureBase64 } } ] }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "language": { "type": "STRING", "enum": ["english", "french"] },
                        "vocabulary": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "source": { "type": "STRING" }, "german": { "type": "STRING" } } } },
                        "sentences": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "source": { "type": "STRING" }, "german": { "type": "STRING" } } } }
                    }
                }
            }
        };

        // KORRIGIERTES MODELL: explizite Version
        const GEMINI_API_KEY = apiKeyInput.value.trim();
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;
        
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorData = await response.json();
                // Detaillierte Fehlermeldung im Konsolen-Log
                console.error("API Error Details:", errorData);
                throw new Error(`API-Fehler: ${errorData.error.message} (Code: ${errorData.error.code})`);
            }
            const result = await response.json();
            const candidate = result?.candidates?.[0];
            const jsonText = candidate?.content?.parts?.[0]?.text;
            if (!jsonText) {
                let errorMessage = "Konnte keine strukturierte Antwort von der KI erhalten.";
                if(candidate?.finishReason && candidate.finishReason !== 'STOP'){ errorMessage += ` Grund: ${candidate.finishReason}`; }
                throw new Error(errorMessage);
            }
            return JSON.parse(jsonText);
        } catch (error) {
            console.error("Verarbeitungsfehler:", error);
            updateStatus(`Fehler bei der Dateianalyse von ${file.name}: ${error.message}`, true, false);
            await new Promise(resolve => setTimeout(resolve, 3000));
            return null; // Return null on error to continue queue processing
        }
    }

    async function getNextFileNumber(folderId) {
        const response = await gapi.client.drive.files.list({
            q: `'${folderId}' in parents and trashed=false`,
            fields: 'files(name)',
            pageSize: 1000
        });
        const files = response.result.files;
        let maxNumber = 0;
        if (files && files.length > 0) {
            for (const file of files) {
                const match = file.name.match(/^(\d+)\s*-.*/);
                if (match && match[1]) {
                    const currentNumber = parseInt(match[1], 10);
                    if (!isNaN(currentNumber) && currentNumber > maxNumber) {
                        maxNumber = currentNumber;
                    }
                }
            }
        }
        return maxNumber;
    }

    async function findFolder(name, parentId) {
        const response = await gapi.client.drive.files.list({
            q: `mimeType='application/vnd.google-apps.folder' and trashed=false and name='${name}' and '${parentId}' in parents`,
            fields: 'files(id, name)',
        });
        const files = response.result.files;
        return (files && files.length > 0) ? files[0].id : null;
    }

    async function createFolder(name, parentId) {
        const fileMetadata = { name, mimeType: 'application/vnd.google-apps.folder', parents: [parentId] };
        const response = await gapi.client.drive.files.create({ resource: fileMetadata, fields: 'id' });
        return response.result.id;
    }

    async function getOrCreateFolderIdByPath(path) {
        const folderNames = path.split('/').filter(name => name.length > 0);
        let parentId = 'root';
        for (const name of folderNames) {
            let folderId = await findFolder(name, parentId);
            if (!folderId) {
                folderId = await createFolder(name, parentId);
            }
            parentId = folderId;
        }
        return parentId;
    }

    async function findSheet(name, parentId) {
        const response = await gapi.client.drive.files.list({
            q: `mimeType='application/vnd.google-apps.spreadsheet' and trashed=false and name='${name}' and '${parentId}' in parents`,
            fields: 'files(id, name)',
        });
        const files = response.result.files;
        return (files && files.length > 0) ? files[0].id : null;
    }

    async function createSheet(title, parentFolderId) {
        const fileMetadata = { name: title, parents: [parentFolderId], mimeType: 'application/vnd.google-apps.spreadsheet' };
        const response = await gapi.client.drive.files.create({ resource: fileMetadata, fields: 'id' });
        return response.result.id;
    }

    function getFormattedDate() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0'); // Monate sind nullbasiert
        const day = String(today.getDate()).padStart(2, '0');
        return `${year}.${month}.${day}`;
    }

    async function uploadCombinedData(data) {
        try {
            const customName = customFilenameInput.value.trim();
            const folderPath = 'Vokabeln/SCAN aus APP';
            updateStatus('Suche/Erstelle Zielordner in Google Drive...', false, true);
            const targetFolderId = await getOrCreateFolderIdByPath(folderPath);
            
            let vocabSheetName;
            let sentencesSheetName;
            
            const langPrefix = data.language === 'french' ? 'FR-DE' : 'ENG-DE';
            const today = getFormattedDate();

            if (customName) {
                updateStatus('Ermittle nächste Dateinummer...', false, true);
                const nextNumber = await getNextFileNumber(targetFolderId) + 1;
                const formattedNumber = String(nextNumber).padStart(2, '0');
                vocabSheetName = `${formattedNumber} - ${customName}`;
                sentencesSheetName = `${formattedNumber} - ${customName} - Sätze`;
            } else {
                vocabSheetName = `${langPrefix} - Meine Vokabelliste - ${today}`;
                sentencesSheetName = `${langPrefix} - Meine Sätze - ${today}`;
            }

            // Vokabeln verarbeiten
            if (data.vocabulary && data.vocabulary.length > 0) {
                updateStatus('Lade Vokabeln hoch...', false, true);
                let sheetId = await findSheet(vocabSheetName, targetFolderId);
                if (!sheetId) {
                    sheetId = await createSheet(vocabSheetName, targetFolderId);
                }
                const values = data.vocabulary.map(v => [v.source, v.german]);
                await appendData(sheetId, values);
                updateResultLink(sheetId, vocabSheetName, "vocab");
            }

            // Sätze verarbeiten
            if (data.sentences && data.sentences.length > 0) {
                updateStatus('Lade Sätze hoch...', false, true);
                let sheetId = await findSheet(sentencesSheetName, targetFolderId);
                 if (!sheetId) {
                    sheetId = await createSheet(sentencesSheetName, targetFolderId);
                }
                const values = data.sentences.map(s => [s.source, s.german]);
                await appendData(sheetId, values);
                updateResultLink(sheetId, sentencesSheetName, "sentence");
            }
            
            if (data.vocabulary.length > 0 || data.sentences.length > 0) {
                 resultsContainer.classList.remove('hidden');
            }

        } catch (error) {
            console.error(error);
            const errorMessage = error.result ? error.result.error.message : error.message;
            updateStatus(`Fehler beim Google Sheets Upload: ${errorMessage}`, true);
        }
    }

    function updateResultLink(sheetId, sheetName, type) {
        const linkId = `${type}-link-${sheetId}`;
        let link = document.getElementById(linkId);
        if (!link) {
            link = document.createElement('a');
            link.id = linkId;
            link.target = "_blank";
            link.className = "block bg-green-100 text-green-800 p-3 rounded-lg hover:bg-green-200 transition duration-300";
            resultLinks.appendChild(link);
        }
        link.href = `https://docs.google.com/spreadsheets/d/${sheetId}/`;
        link.textContent = `${sheetName} öffnen`;
    }

    async function appendData(spreadsheetId, values) {
        await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: spreadsheetId, range: 'A1', valueInputOption: 'USER_ENTERED', resource: { values: values } });
    }

    function updateStatus(message, isError = false, showLoaderState = false) {
        statusText.textContent = message;
        statusText.className = isError ? 'text-red-600 font-semibold' : 'text-gray-600';
        loader.classList.toggle('hidden', !showLoaderState);
        statusText.classList.remove('hidden');
    }
</script>
</body>
</html>
