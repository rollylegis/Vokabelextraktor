<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vokabelextraktor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Cropper.js für die Zuschneide-Funktion -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.2/cropper.min.js" defer></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Stellt sicher, dass das Cropper-Bild nicht zu groß wird */
        #camera-preview-image-container > img {
            max-width: 100%;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen">
    <div class="container mx-auto p-4 max-w-2xl w-full">
        <div class="bg-white rounded-2xl shadow-lg p-6 sm:p-8">
            <header class="text-center mb-6">
                <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">Vokabelextraktor</h1>
                <p class="text-gray-600 mt-2">Extrahiere Vokabeln aus Bildern oder PDFs und speichere sie direkt in Google Sheets & Excel.</p>
            </header>

            <div id="auth-container" class="text-center">
                <input type="text" id="api-key-input" placeholder="Dein Google API Key" class="w-full p-3 border border-gray-300 rounded-lg mb-2 text-center" value="">
                <input type="text" id="client-id-input" placeholder="Deine Google Client ID" class="w-full p-3 border border-gray-300 rounded-lg mb-4 text-center" value="">
                <button id="authorize_button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg w-full transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>Mit Google anmelden</button>
                <button id="signout_button" class="hidden bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-6 rounded-lg w-full mt-2 transition duration-300">Abmelden</button>
            </div>

            <main id="app-container" class="hidden">
                <div class="mb-4">
                    <label for="custom-filename-input" class="block text-sm font-medium text-gray-700 mb-1">Benutzerdefinierter Dateiname (optional):</label>
                    <input type="text" id="custom-filename-input" class="w-full p-3 border border-gray-300 rounded-lg" placeholder="z.B. Lektion 5 - Unregelmäßige Verben">
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <label for="camera-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"></path><circle cx="12" cy="13" r="3"></circle></svg>
                        <span>Kamera</span>
                    </label>
                    <input type="file" id="camera-input" accept="image/*" capture="environment" class="hidden">
                    
                    <label for="upload-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                        <span>Dateien hochladen</span>
                    </label>
                    <input type="file" id="upload-input" accept="image/*,application/pdf" class="hidden" multiple>
                    
                    <button id="paste-button" class="cursor-pointer bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                        <span>Zwischenablage</span>
                    </button>
                </div>
                
                <div id="action-buttons" class="flex justify-center gap-4 mb-6">
                    <button id="start-processing-button" class="hidden cursor-pointer bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                        <span>Verarbeitung starten</span>
                    </button>
                    <button id="clear-queue-button" class="hidden cursor-pointer bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300 flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                        <span>Warteschlange leeren</span>
                    </button>
                </div>

                <div id="preview-container" class="mb-6 text-center hidden">
                     <h2 class="text-xl font-semibold mb-3">Vorschau der Warteschlange</h2>
                    <div id="previews-wrapper" class="flex flex-wrap gap-4 justify-center p-4 bg-gray-50 rounded-lg"></div>
                </div>

                <div id="status-container" class="text-center p-4 bg-gray-50 rounded-lg min-h-[100px] flex flex-col items-center justify-center">
                    <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-12 w-12 hidden mb-2"></div>
                    <p id="status-text" class="text-gray-500">Bitte wähle eine oder mehrere Dateien aus.</p>
                </div>

                <div id="results-container" class="mt-6 text-center hidden">
                    <h2 class="text-xl font-semibold mb-3">Ergebnisse</h2>
                    <div id="result-links" class="space-y-3">
                       <!-- Links werden hier dynamisch eingefügt -->
                    </div>
                </div>
            </main>
        </div>
        <footer class="text-center mt-4 text-sm text-gray-500">
            <p>&copy; 2026 Vokabelextraktor. Erstellt mit Gemini & Google Sheets API.</p>
            <p class="text-xs mt-1 text-gray-400">Version: 06.02.26 16:05 (Auto-Latest)</p>
        </footer>
    </div>
    
    <!-- Modal for Camera Preview and Cropping -->
    <div id="camera-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 max-w-3xl w-full">
            <h2 class="text-2xl font-bold mb-4 text-center">Bild anpassen</h2>
            <div id="camera-preview-image-container" class="mb-4 max-h-[60vh] overflow-hidden bg-gray-200">
                <img id="camera-preview-image" src="" alt="Kameravorschau">
            </div>
            <div class="flex flex-col sm:flex-row justify-center items-center gap-4">
                <button id="retake-photo-button" class="w-full sm:w-auto cursor-pointer bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300">Neu aufnehmen</button>
                <button id="add-selection-to-queue-button" class="w-full sm:w-auto cursor-pointer bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300">Auswahl zur Warteschlange</button>
                <button id="finish-selection-button" class="w-full sm:w-auto cursor-pointer bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-center transition duration-300">Auswahl abgeschlossen</button>
            </div>
        </div>
    </div>


<script type="text/javascript">
    window.onload = function() {
        const savedApiKey = localStorage.getItem('vokabelAppApiKey');
        const savedClientId = localStorage.getItem('vokabelAppClientId');
        if (savedApiKey) apiKeyInput.value = savedApiKey;
        if (savedClientId) clientIdInput.value = savedClientId;
    };

    const authorizeButton = document.getElementById('authorize_button');
    const signoutButton = document.getElementById('signout_button');
    const apiKeyInput = document.getElementById('api-key-input');
    const clientIdInput = document.getElementById('client-id-input');
    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    const cameraInput = document.getElementById('camera-input');
    const uploadInput = document.getElementById('upload-input');
    const pasteButton = document.getElementById('paste-button');
    const startProcessingButton = document.getElementById('start-processing-button');
    const clearQueueButton = document.getElementById('clear-queue-button');
    const customFilenameInput = document.getElementById('custom-filename-input');
    const previewContainer = document.getElementById('preview-container');
    const previewsWrapper = document.getElementById('previews-wrapper');
    const statusContainer = document.getElementById('status-container');
    const statusText = document.getElementById('status-text');
    const loader = document.getElementById('loader');
    const resultsContainer = document.getElementById('results-container');
    const resultLinks = document.getElementById('result-links');
    
    // Modal elements
    const cameraModal = document.getElementById('camera-modal');
    const cameraPreviewImage = document.getElementById('camera-preview-image');
    const retakePhotoButton = document.getElementById('retake-photo-button');
    const addSelectionToQueueButton = document.getElementById('add-selection-to-queue-button');
    const finishSelectionButton = document.getElementById('finish-selection-button');

    let gapiInited = false;
    let gisInited = false;
    let tokenClient;
    let fileQueue = [];
    let cropper;
    
    const SCOPES = 'https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/spreadsheets';

    authorizeButton.onclick = handleAuthClick;
    signoutButton.onclick = handleSignoutClick;

    gapi.load('client', initializeGapiClient);
    
    function initializeGisClient() {
        gisInited = true;
        maybeEnableButtons();
    }

    const gsiScript = document.createElement('script');
    gsiScript.src = 'https://accounts.google.com/gsi/client';
    gsiScript.async = true;
    gsiScript.defer = true;
    gsiScript.onload = initializeGisClient;
    document.body.appendChild(gsiScript);

    async function initializeGapiClient() {
        await gapi.client.init({
            discoveryDocs: [
                'https://sheets.googleapis.com/$discovery/rest?version=v4',
                'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
            ],
        });
        gapiInited = true;
        maybeEnableButtons();
    }

    function maybeEnableButtons() {
        if (gapiInited && gisInited) {
            authorizeButton.disabled = false;
            trySilentSignIn();
        }
    }

    function trySilentSignIn() {
        const apiKey = apiKeyInput.value.trim();
        const clientId = clientIdInput.value.trim();
        if (apiKey && clientId) {
            gapi.client.setApiKey(apiKey);
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: clientId,
                scope: SCOPES,
                callback: (resp) => {
                    if (resp.error === undefined) {
                        updateUIVisibility(true);
                    }
                },
            });
            tokenClient.requestAccessToken({ prompt: 'none' });
        }
    }

    function handleAuthClick() {
        const apiKey = apiKeyInput.value.trim();
        const clientId = clientIdInput.value.trim();
        if (!apiKey || !clientId) {
            updateStatus('Bitte gib API Key und Client ID ein.', true);
            return;
        }
        localStorage.setItem('vokabelAppApiKey', apiKey);
        localStorage.setItem('vokabelAppClientId', clientId);

        gapi.client.setApiKey(apiKey);
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: clientId,
            scope: SCOPES,
            callback: (resp) => { 
                if (resp.error !== undefined) {
                    updateStatus(`Anmeldefehler: ${resp.error}`, true);
                    return;
                }
                updateUIVisibility(true);
            },
        });
        tokenClient.requestAccessToken({prompt: 'select_account'});
    }

    function handleSignoutClick() {
        const token = gapi.client.getToken();
        if (token !== null) {
            google.accounts.oauth2.revoke(token.access_token);
            gapi.client.setToken('');
            updateUIVisibility(false);
        }
    }

    function updateUIVisibility(isSignedIn) {
        if (isSignedIn) {
            authContainer.classList.add('hidden');
            appContainer.classList.remove('hidden');
            signoutButton.classList.remove('hidden');
            authorizeButton.classList.add('hidden');
            updateStatus('Bereit für Uploads!');
        } else {
            authContainer.classList.remove('hidden');
            appContainer.classList.add('hidden');
            signoutButton.classList.add('hidden');
            authorizeButton.classList.remove('hidden');
        }
    }

    cameraInput.addEventListener('change', handleCameraInput);
    uploadInput.addEventListener('change', (event) => addFilesToQueue(event.target.files));
    pasteButton.addEventListener('click', handlePaste);
    startProcessingButton.addEventListener('click', processQueue);
    clearQueueButton.addEventListener('click', clearQueue);
    retakePhotoButton.addEventListener('click', () => cameraInput.click());
    addSelectionToQueueButton.addEventListener('click', addSelectionToQueue);
    finishSelectionButton.addEventListener('click', closeCameraModal);

    function handleCameraInput(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            cameraPreviewImage.src = e.target.result;
            cameraModal.classList.remove('hidden');
            if (cropper) cropper.destroy();
            cropper = new Cropper(cameraPreviewImage, { aspectRatio: NaN, viewMode: 1, background: false });
        };
        reader.readAsDataURL(file);
    }

    function addSelectionToQueue() {
        if (!cropper) return;
        cropper.getCroppedCanvas({ imageSmoothingQuality: 'high' }).toBlob((blob) => {
            const file = new File([blob], `camera-selection-${Date.now()}.png`, { type: 'image/png' });
            addFilesToQueue([file]);
            const originalText = addSelectionToQueueButton.innerHTML;
            addSelectionToQueueButton.innerHTML = '<span>Hinzugefügt!</span>';
            setTimeout(() => { addSelectionToQueueButton.innerHTML = originalText; }, 1000);
        }, 'image/png');
    }

    function closeCameraModal() {
        cameraModal.classList.add('hidden');
        if (cropper) { cropper.destroy(); cropper = null; }
        cameraInput.value = '';
    }

    async function handlePaste() {
        try {
            if (!navigator.clipboard?.read) return;
            const items = await navigator.clipboard.read();
            for (const item of items) {
                const type = item.types.find(t => t.startsWith('image/'));
                if (type) {
                    const blob = await item.getType(type);
                    addFilesToQueue([new File([blob], "clipboard-image.png", { type: blob.type })]);
                    return;
                }
            }
        } catch (e) { console.error(e); }
    }

    function addFilesToQueue(fileList) {
        if (!fileList) return;
        Array.from(fileList).forEach(f => fileQueue.push({ file: f, timestamp: new Date() }));
        updateQueuePreview();
    }

    function removeFromQueue(index) {
        fileQueue.splice(index, 1);
        updateQueuePreview();
    }

    async function updateQueuePreview() {
        previewsWrapper.innerHTML = '';
        previewContainer.classList.toggle('hidden', fileQueue.length === 0);
        for (let i=0; i<fileQueue.length; i++) {
            const item = fileQueue[i];
            const div = document.createElement('div');
            div.className = 'relative';
            const img = document.createElement('img');
            img.className = "max-h-32 rounded-lg shadow-md";
            const reader = new FileReader();
            reader.onload = (e) => img.src = e.target.result;
            reader.readAsDataURL(item.file);
            const btn = document.createElement('button');
            btn.innerHTML = 'X';
            btn.className = "absolute -top-2 -right-2 bg-red-600 text-white rounded-full w-6 h-6 text-xs font-bold shadow-md";
            btn.onclick = () => removeFromQueue(i);
            div.appendChild(img);
            div.appendChild(btn);
            previewsWrapper.appendChild(div);
        }
        startProcessingButton.classList.toggle('hidden', fileQueue.length === 0);
        clearQueueButton.classList.toggle('hidden', fileQueue.length === 0);
    }
    
    function clearQueue() { fileQueue = []; updateQueuePreview(); }

    async function processQueue() {
        if (fileQueue.length === 0) return;
        resultsContainer.classList.add('hidden');
        resultLinks.innerHTML = '';
        let allVocab = [], allSentences = [], detectedLang = 'english';

        const sortedQueue = fileQueue.sort((a, b) => a.timestamp - b.timestamp);

        for (let i = 0; i < sortedQueue.length; i++) {
            const file = sortedQueue[i].file;
            updateStatus(`[${i+1}/${sortedQueue.length}] Analysiere: ${file.name}`, false, true);
            const base64 = await new Promise(r => {
                const reader = new FileReader();
                reader.onload = e => r(e.target.result.split(',')[1]);
                reader.readAsDataURL(file);
            });
            
            // Verwende die neue Fallback-Funktion mit Priorität auf "Latest"
            const data = await processFileWithFallback(file.type, base64);
            
            if (data) {
                if (i === 0) detectedLang = data.language;
                if (data.vocabulary) allVocab.push(...data.vocabulary);
                if (data.sentences) allSentences.push(...data.sentences);
            }
        }

        if (allVocab.length === 0 && allSentences.length === 0) {
             updateStatus('Keine Daten extrahiert. Überprüfe API-Key/Quota.', true, false);
             return;
        }

        updateStatus('Upload zu Google Drive...', false, true);
        await uploadCombinedData({ language: detectedLang, vocabulary: allVocab, sentences: allSentences });
        updateStatus(`Fertig! ${allVocab.length} Vokabeln & ${allSentences.length} Sätze.`, false, false);
        fileQueue = []; updateQueuePreview(); customFilenameInput.value = '';
    }

    // NEU: Diese Funktion probiert mehrere Modelle durch, "Latest" ist Prio 1
    async function processFileWithFallback(mimeType, base64) {
        // Liste der Modelle, die wir probieren wollen - Latest als erstes!
        const modelsToTry = [
            'gemini-1.5-flash-latest', // Die empfohlene "Zukunftssichere" Variante
            'gemini-1.5-flash',       // Der stabile Standard
            'gemini-1.5-flash-002'    // Spezifischer Checkpoint
        ];

        for (const modelName of modelsToTry) {
            console.log(`Versuche Modell: ${modelName}...`);
            const data = await processFile(mimeType, base64, modelName);
            if (data) {
                console.log(`Erfolg mit Modell: ${modelName}`);
                return data; // Erfolg! Wir brechen die Schleife ab und geben die Daten zurück
            }
            // Wenn nicht erfolgreich, warten wir kurz und probieren das nächste Modell
            await new Promise(r => setTimeout(r, 500));
        }
        
        // Wenn wir hier ankommen, haben alle Modelle versagt
        console.error("Alle Modelle fehlgeschlagen.");
        return null;
    }
    
    async function processFile(mimeType, base64, modelName) {
        const payload = {
            contents: [{ parts: [
                { text: "Extrahiere Sprache (english/french), Vokabeln (source/german) und Beispielsätze (source/german) als JSON." },
                { inlineData: { mimeType, data: base64 } }
            ]}],
            generationConfig: { 
                responseMimeType: "application/json",
                responseSchema: { type: "OBJECT", properties: {
                    "language": { "type": "STRING", "enum": ["english", "french"] },
                    "vocabulary": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "source": { "type": "STRING" }, "german": { "type": "STRING" } } } },
                    "sentences": { "type": "ARRAY", "items": { "type": "OBJECT", "properties": { "source": { "type": "STRING" }, "german": { "type": "STRING" } } } }
                }}
            }
        };
        
        const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKeyInput.value.trim()}`;
        
        try {
            const resp = await fetch(url, { method: 'POST', body: JSON.stringify(payload) });
            if (!resp.ok) {
                 const errData = await resp.json().catch(() => ({}));
                 // Wir werfen keinen harten Fehler, damit die Schleife weiterlaufen kann, loggen es aber
                 console.warn(`Modell ${modelName} fehlgeschlagen:`, errData);
                 return null;
            }
            const result = await resp.json();
            if (!result.candidates?.[0]?.content?.parts?.[0]?.text) {
                return null;
            }
            return JSON.parse(result.candidates[0].content.parts[0].text);
        } catch (e) { 
            console.warn(`Fehler bei Modell ${modelName}:`, e);
            return null; 
        }
    }

    async function getNextFileNumber(folderId) {
        const resp = await gapi.client.drive.files.list({ q: `'${folderId}' in parents and trashed=false`, fields: 'files(name)' });
        let max = 0;
        resp.result.files.forEach(f => {
            const m = f.name.match(/^(\d+)\s*-.*/);
            if (m) max = Math.max(max, parseInt(m[1]));
        });
        return max;
    }

    async function getOrCreateFolderId(path) {
        let parentId = 'root';
        for (const name of path.split('/')) {
            const resp = await gapi.client.drive.files.list({ q: `name='${name}' and '${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false` });
            if (resp.result.files.length > 0) parentId = resp.result.files[0].id;
            else {
                const created = await gapi.client.drive.files.create({ resource: { name, mimeType: 'application/vnd.google-apps.folder', parents: [parentId] }, fields: 'id' });
                parentId = created.result.id;
            }
        }
        return parentId;
    }

    async function appendToSheet(id, values) {
        await gapi.client.sheets.spreadsheets.values.append({ spreadsheetId: id, range: 'A1', valueInputOption: 'USER_ENTERED', resource: { values } });
    }

    async function exportToExcel(sheetId, sheetName, folderId) {
        updateStatus(`Erstelle Excel-Backup: ${sheetName}.xlsx`, false, true);
        const accessToken = gapi.auth.getToken().access_token;
        const exportUrl = `https://www.googleapis.com/drive/v3/files/${sheetId}/export?mimeType=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`;
        
        try {
            const resp = await fetch(exportUrl, { headers: { Authorization: `Bearer ${accessToken}` } });
            const blob = await resp.blob();
            
            const metadata = { name: `${sheetName}.xlsx`, parents: [folderId], mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' };
            const formData = new FormData();
            formData.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            formData.append('file', blob);

            await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: { Authorization: `Bearer ${accessToken}` },
                body: formData
            });
        } catch (e) { console.error("Excel Export fehlgeschlagen:", e); }
    }

    async function uploadCombinedData(data) {
        try {
            const customName = customFilenameInput.value.trim();
            const folderId = await getOrCreateFolderId('Schule Kinder/Vokabeln/SCAN aus APP');
            const langPrefix = data.language === 'french' ? 'FR-DE' : 'ENG-DE';
            const today = new Date().toISOString().split('T')[0].replace(/-/g, '.');

            let vName, sName;
            if (customName) {
                const nextNum = String(await getNextFileNumber(folderId) + 1).padStart(2, '0');
                vName = `${nextNum} - ${customName}`;
                sName = `${nextNum} - ${customName} - Sätze`;
            } else {
                vName = `${langPrefix} - Vokabeln - ${today}`;
                sName = `${langPrefix} - Sätze - ${today}`;
            }

            if (data.vocabulary.length > 0) {
                const sheet = await gapi.client.drive.files.create({ resource: { name: vName, parents: [folderId], mimeType: 'application/vnd.google-apps.spreadsheet' }, fields: 'id' });
                await appendToSheet(sheet.result.id, data.vocabulary.map(v => [v.source, v.german]));
                await exportToExcel(sheet.result.id, vName, folderId); // AUTO EXCEL EXPORT
                addResultLink(sheet.result.id, vName);
            }
            if (data.sentences.length > 0) {
                const sheet = await gapi.client.drive.files.create({ resource: { name: sName, parents: [folderId], mimeType: 'application/vnd.google-apps.spreadsheet' }, fields: 'id' });
                await appendToSheet(sheet.result.id, data.sentences.map(s => [s.source, s.german]));
                await exportToExcel(sheet.result.id, sName, folderId); // AUTO EXCEL EXPORT
                addResultLink(sheet.result.id, sName);
            }
            resultsContainer.classList.remove('hidden');
        } catch (e) { updateStatus(`Fehler: ${e.message}`, true); }
    }

    function addResultLink(id, name) {
        const a = document.createElement('a');
        a.href = `https://docs.google.com/spreadsheets/d/${id}/`;
        a.target = "_blank";
        a.className = "block bg-green-100 text-green-800 p-3 rounded-lg hover:bg-green-200 transition mb-2";
        a.textContent = `${name} öffnen`;
        resultLinks.appendChild(a);
    }

    function updateStatus(msg, isErr, showLoader) {
        statusText.textContent = msg;
        statusText.className = isErr ? 'text-red-600 font-semibold' : 'text-gray-600';
        loader.classList.toggle('hidden', !showLoader);
        statusText.classList.remove('hidden');
    }
</script>
</body>
</html>
